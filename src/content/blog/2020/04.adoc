title=Project Reactor (Part 3 of 3)
date=2020-10-20
type=post
tags=spring,reactor,java,webflux,jhipster
status=published
~~~~~~

== So far...

In the https://www.adamldavis.com/blog/2020/03.html[previous] post we introduced Reactor testing and backpressure.

To summarize:

1. https://www.adamldavis.com/blog/2020/02.html[Part 1]: Getting started with Reactor
2. https://www.adamldavis.com/blog/2020/03.html[Part 2]: Flux, Mono, zipping, Tuples, and retry
3. Part 3: WebFlux and WebClient with a dip into JHipster

== Prerequisites

For this post you should have a good understanding of
https://leanpub.com/modernjavasecondedition/[Java]
and https://spring.io/projects/spring-boot[Spring Boot]
and have read the previous posts about Reactor.

== JHipster

JHipster is a code generation tool primarily for building Spring-Boot based projects
with either a React or Angular front end - although it can be extended via blueprints and
there are several that allow you to create a Vue.js front end or Micronaut back-end for two examples.

It also has a feature allowing you to create a Spring Boot WebFlux project.

WebFlux is Spring's framework for asynchronous, non-blocking web applications - and it works with
Reactive types, especially project Reactor (Flux, Mono, etc.).

To get started, install https://nodejs.org/en/[Node] (>10.20.1) and https://www.jhipster.tech/installation/[JHipster] (latest)

- Then, from the terminal, make a new directory (named "hip-webflux"), and run `jhipster`
- Follow the prompts, and choose monolith and then _Reactive_ (this will create a Spring Boot WebFlux project)
- For database, you can pick MongoDB, or Cassandra (the reactive generator doesn't support SQL at the moment)
- For front end, you can pick React or Angular
- Pick Maven or Gradle

...This takes a while since it has to load a bunch of dependencies...

Then you should see output like the following:
```

Server application generated successfully.

Run your Spring Boot application:
./mvnw

Client application generated successfully.

Start your Webpack development server with:
 npm start


> hip@0.0.1-SNAPSHOT cleanup /home/adavis/github/adamldavis/hip-webflux
> rimraf target/classes/static/

INFO! Congratulations, JHipster execution is complete!
```

== JDL

After creating the basic project, let's add some entities.

One of the cool things about JHipster is JDL (Jhipster Domain Language).
Its a DSL for creating projects and entities.
Create a file named "hip.jdl" and put in the following:

```
entity Person {
  name String required
  age Integer min(0) max(142)
}
```

(Feel free to mess around with your JDL and make it more complicated, but for this example, let's keep it simple)

Import the JDL by running `jhipster import-jdl hip.jdl`

Now open the project with your favorite IDE (like IntelliJ IDEA for example) and take
a look at the PersonController.

JHipster automatically creates an AuditEvent database for auditing (create, update, delete record events).
Open up the file named "AuditResource" under the "com.mycompany.myapp.web.rest" package (Under src/main/java/).
It should have a "getAll" method that looks something like this:

```java
@GetMapping
public Mono<ResponseEntity<Flux<AuditEvent>>> getAll(ServerHttpRequest request, Pageable pageable) {
    return auditEventService.count()
        .map(total -> new PageImpl<>(new ArrayList<>(), pageable, total))
        .map(page -> PaginationUtil.generatePaginationHttpHeaders(UriComponentsBuilder.fromHttpRequest(request), page))
        .map(headers -> ResponseEntity.ok().headers(headers).body(auditEventService.findAll(pageable)));
}
```

WebFlux allows you to return Reactor types like Mono and Flux from controller methods
and implements a reactive, asynchronous web server using https://netty.io/[Netty] by default.

A typical web server uses a large number of Threads and handles each request in one thread.
The problem with this is that Threads in Java are kind of heavy weight in Java
(this should be fixed by project Loom and virtual threads in Java 15+).
This allows a single Thread to block without holding back the entire application,
however if you have a lot of blocking threads, it can starve your application of available Threads.

Netty instead uses an http://normanmaurer.me/presentations/2014-netflix-netty/slides.html#11.0[EventLoop]
per Thread for I/O.
WebFlux enables and simplifies the Java API using Reactive Streams (of which Reactor is one implementation).

== No Blocking!

Since the threads in WebFlux are meant to be non-blocking, you must be careful not to block them.
For example, don't call `block()` or `Thread.sleep`.
There's a project called https://github.com/reactor/BlockHound[BlockHound] to help enforce this
rule throughout your application.
(This doesn't mean _no_ threads can block; only blocking should happen in dedicated threads)

To implement this, your application should be reactive "all the way down".
So if you have a database, reading from it should also be reactive and non-blocking.
Projects like https://r2dbc.io/[r2dbc] and Spring https://spring.io/projects/spring-data-r2dbc[spring-data-r2dbc]
help, among others.

== WebClient

WebFlux also includes
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/client/WebClient.html[WebClient]
which is a reactive replacement for RestTemplate.
It makes asynchronous, non-blocking HTTP requests.

You can create an instance of WebClient using the builder pattern starting from the static WebClient.builder() method.
For example:

```java
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
// later on...
WebClient myWebClient = WebClient.builder()
 .baseUrl("http://localhost:8080/api-to-call/")
 .defaultCookie("cookieKey", "cookieValue")
 .defaultHeader(HttpHeaders.CONTENT_TYPE,
   MediaType.APPLICATION_JSON_VALUE)
 .build();
```

This builds a WebClient with given baseUrl.
It also provides a cookie and header to use for every request.
There are many more methods to configure the WebClient.
Each request starts with defining the HTTP method,
then you can specify an additional URL path (with or without path variables) and call
exchange which returns a Mono<ClientResponse>.
For example, to get a person from some `/v1/persons` REST api:

```
// get the Course with ID=1 and print it out:
myWebClient.get()
    .uri("/v1/persons/{id}", 1L)
    .exchange()
    .flatMap((ClientResponse response) ->
      response.bodyToMono(Person.class))
    .subscribe(person -> System.out.println("person = " + person));
```

The WebClient thus enables all of your HTTP calls to be reactive.
The Spring team likes WebClient so much, they  recommend everyone use it over RestTemplate.

== Conclusion

I hope you got something from this three part series.
Reactive programming in Java isn't always necessary - it's for enabling thousands of
transactions a second, so you might not need it - but when any
application becomes popular enough, you tend to need high throughput and performance.

Eventually when Java has virtual threads it will make threads more lightweight, however,
Reactive will still be useful due to its backpressure handling, retry logic,
and other benefits.

1. https://www.adamldavis.com/blog/2020/02.html[Part 1]: Getting started with Reactor
2. https://www.adamldavis.com/blog/2020/03.html[Part 2]: Flux, Mono, zipping, Tuples, and retry
3. https://www.adamldavis.com/blog/2020/04.html[Part 3]: WebFlux and WebClient
